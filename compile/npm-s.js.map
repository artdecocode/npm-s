{
"version":3,
"file":"compile/npm-s.js",
"lineCount":12,
"mappings":"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",
"sources":["node_modules/erte/src/index.js","node_modules/child_process/index.js","node_modules/stream/index.js","node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/spawncommand/src/index.js","src/depack.js","src/index.js"],
"sourcesContent":["import Diff from './diff'\n\nconst colors = {\n  'black': 30,\n  'red': 31,\n  'green': 32,\n  'yellow': 33,\n  'blue': 34,\n  'magenta': 35,\n  'cyan': 36,\n  'white': 37,\n  'grey': 90,\n}\n\nconst backgroundColors = {\n  'black': 40,\n  'red': 41,\n  'green': 42,\n  'yellow': 43,\n  'blue': 44,\n  'magenta': 45,\n  'cyan': 46,\n  'white': 47,\n}\n\n/**\n * Color the foreground.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function c(string, color) {\n  const cc = colors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Color the background.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function b(string, color) {\n  const cc = backgroundColors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Compares two strings and outputs a coloured version where strings don't match.\n * @param {string} source A string to compare.\n * @param {string} target Target string to compare with.\n * @returns {string} A string which uses shell-codes to highligh differences.\n */\nexport default function erte(source, target) {\n  const diff = new Diff()\n  const d = diff.diff(source, target)\n  const m = d.map(({ added, removed, value }) => {\n    let p\n    const s = value.split(' ')\n    if (added) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'green')).join(b(' ', 'green'))\n    } else if (removed) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'red')).join(b(' ', 'red'))\n    } else {\n      p = c(value, 'grey')\n    }\n    return p\n  })\n  const s = m.join('')\n  return s\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_erte.Color} Color The color to apply.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {('black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'|'grey')} _erte.Color The color to apply.\n */\n","export default child_process\nexport const {\n  ChildProcess,\n  exec,\n  execFile,\n  execFileSync,\n  execSync,\n  fork,\n  spawn,\n  spawnSync,\n} = child_process","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","import { spawn, fork as forkCp } from 'child_process'\nimport { collect } from 'catchment'\n\n/**\n * @param {!child_process.ChildProcess} proc\n * @returns {!Promise<_spawncommand.PromiseResult>}\n */\nconst getPromise = async (proc) => {\n  const [code, stdout, stderr] = await Promise.all([\n    new Promise((resolve, reject) => {\n      proc.on('error', reject)\n        .on('exit', (code) => {\n          resolve(code)\n        })\n    }),\n    proc.stdout ? collect(proc.stdout) : undefined,\n    proc.stderr ? collect(proc.stderr) : undefined,\n  ])\n  return {\n    code,\n    stdout,\n    stderr,\n  }\n}\n\n/**\n * Spawns a new process using the `command` and returns an instance of a ChildProcess, extended to have a `promise` property which is resolved when the process exits. The resolved value is an object with `stdout`, `stderr` and `code` properties.\n * @param {string} command The command to run.\n * @param {!Array<string>} [args] List of string arguments.\n * @param {!child_process.SpawnOptions} [options] Options used to spawn.\n */\nexport default function spawnCommand(command, args, options) {\n  if (!command) throw new Error('Please specify a command to spawn.')\n  const proc = /** @type {!_spawncommand.ChildProcessWithPromise} */ (spawn(command, args, options))\n\n  const promise = getPromise(proc)\n  proc.promise = promise\n  /** @suppress {checkTypes} */\n  proc.spawnCommand = proc['spawnargs'].join(' ')\n  return proc\n}\n\n/**\n * Forks a process and assign a `promise` property to it, resolved with `stderr`, `stdout` and `code` properties on exit.\n * @param {string} mod The module to run in the child.\n * @param {!Array<string>} [args] List of string arguments.\n * @param {!child_process.ForkOptions} [options] Options to fork the process with.\n */\nexport function fork(mod, args, options) {\n  if (!mod) throw new Error('Please specify a module to fork')\n  const proc = /** @type {!_spawncommand.ChildProcessWithPromise} */ (forkCp(mod, args, options))\n\n  const promise = getPromise(proc)\n  proc.promise = promise\n  /** @suppress {checkTypes} */\n  proc.spawnCommand = proc['spawnargs'].join(' ')\n  return proc\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_spawncommand.PromiseResult} PromiseResult\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _spawncommand.PromiseResult\n * @prop {string} stdout The accumulated result of the `stdout` stream.\n * @prop {string} stderr The accumulated result of the `stderr` stream.\n * @prop {number} code The code with which the process exited.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').SpawnOptions} child_process.SpawnOptions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').ForkOptions} child_process.ForkOptions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').ChildProcess} child_process.ChildProcess\n */\n\n/* documentary types/cp.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_spawncommand.ChildProcessWithPromise} ChildProcessWithPromise A child process with an extra `promise` property.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {child_process.ChildProcess & _spawncommand.$ChildProcessWithPromise} _spawncommand.ChildProcessWithPromise A child process with an extra `promise` property.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _spawncommand.$ChildProcessWithPromise A child process with an extra `promise` property.\n * @prop {!Promise<!_spawncommand.PromiseResult>} promise A promise resolved when the process exits.\n * @prop {string} spawnCommand The spawn arguments joined by whitespace.\n */\n","import '../types/externs'\nimport npmS from './'\n\nmodule.exports = {\n  '_npmS': npmS,\n}","import { c as co } from 'erte'\nimport spawncommand from 'spawncommand'\n\n/**\n * @param {string} script The script to run with NPM.\n */\nconst run = (script) => {\n  const proc = spawncommand('npm', ['run', script])\n  proc.stdout.pipe(process.stdout)\n  proc.stderr.pipe(process.stderr)\n  const { promise } = proc\n  return { proc, promise }\n}\n\n/**\n * @type {_npmS.npmS}\n */\nexport default async function npmS(config) {\n  if (!config) throw new Error('Config is expected')\n  const { scripts = [] } = config\n  return await scripts\n    .reduce(async (acc, command) => {\n      acc = await acc\n      const { promise } = run(command)\n      const c = await promise\n      const { code } = c\n      if (code) {\n        const err = new Error(`Command \"${co(command, 'yellow')}\" existed with code ${co(code, 'red')}`)\n        err.code = code\n        throw err\n      }\n\n      return [...acc, c]\n    }, [])\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../types').npmS} _npmS.npmS\n */\n"],
"names":["colors","c","string","color","cc","spawn","child_process","Writable","stream","getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","join","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","homedir","os","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","re","RegExp","source","replace","j","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","pipeError","streamA","streamB","once","emit","Catchment","options","binary","rs","opts","er","proxyError","wrap","_","_caughtData","_promise","Promise","r","on","d","Buffer","concat","indexOf","pipe","chunk","encoding","callback","push","collect","readable","promise","res","getPromise","proc","code","stdout","stderr","all","resolve","reject","module","exports","npmS","config","scripts","reduce","acc","command","spawnCommand","process","err","co"]
}
